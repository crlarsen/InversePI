# InversePI-64
#
# Copyright 2022, Chris Larsen
# You may use this code, without warranty expressed or implied, as you wish
# with the provision that any work derived from this code retains my
# copyright notice.
#
# Python script which uses Newton's Method to compute the reciprocal of a
# binary64 value.
#
# This script is not production quality code. It is only Proof Of Concept
# (POC) code. It expects to receive only IEEE 754 binary64 Normal numbers
# as input, and to generate only IEEE 754 Normal numbers as output.
#
# NO ATTEMPT IS MADE TO HANDLE:
# o NaNs,
# o Infinities,
# o Zeroes, or
# o Subnormal numbers.

import argparse
import sys

table = [ 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e,
          0x7e, 0x7d, 0x7d, 0x7d, 0x7d, 0x7c, 0x7c, 0x7c,
          0x7c, 0x7b, 0x7b, 0x7b, 0x7b, 0x7a, 0x7a, 0x7a,
          0x7a, 0x79, 0x79, 0x79, 0x79, 0x78, 0x78, 0x78,
          0x78, 0x78, 0x77, 0x77, 0x77, 0x77, 0x76, 0x76,
          0x76, 0x76, 0x75, 0x75, 0x75, 0x75, 0x74, 0x74,
          0x74, 0x74, 0x74, 0x73, 0x73, 0x73, 0x73, 0x72,
          0x72, 0x72, 0x72, 0x72, 0x71, 0x71, 0x71, 0x71,
          0x70, 0x70, 0x70, 0x70, 0x70, 0x6f, 0x6f, 0x6f,
          0x6f, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6d, 0x6d,
          0x6d, 0x6d, 0x6d, 0x6c, 0x6c, 0x6c, 0x6c, 0x6b,
          0x6b, 0x6b, 0x6b, 0x6b, 0x6a, 0x6a, 0x6a, 0x6a,
          0x6a, 0x69, 0x69, 0x69, 0x69, 0x69, 0x68, 0x68,
          0x68, 0x68, 0x67, 0x67, 0x67, 0x67, 0x67, 0x66,
          0x66, 0x66, 0x66, 0x66, 0x65, 0x65, 0x65, 0x65,
          0x65, 0x64, 0x64, 0x64, 0x64, 0x64, 0x63, 0x63,
          0x63, 0x63, 0x63, 0x62, 0x62, 0x62, 0x62, 0x62,
          0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x60, 0x60,
          0x60, 0x60, 0x60, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
          0x5e, 0x5e, 0x5e, 0x5e, 0x5e, 0x5d, 0x5d, 0x5d,
          0x5d, 0x5d, 0x5d, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
          0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5a, 0x5a,
          0x5a, 0x5a, 0x5a, 0x59, 0x59, 0x59, 0x59, 0x59,
          0x59, 0x58, 0x58, 0x58, 0x58, 0x58, 0x57, 0x57,
          0x57, 0x57, 0x57, 0x57, 0x56, 0x56, 0x56, 0x56,
          0x56, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x54,
          0x54, 0x54, 0x54, 0x54, 0x54, 0x53, 0x53, 0x53,
          0x53, 0x53, 0x53, 0x52, 0x52, 0x52, 0x52, 0x52,
          0x52, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x50,
          0x50, 0x50, 0x50, 0x50, 0x50, 0x4f, 0x4f, 0x4f,
          0x4f, 0x4f, 0x4f, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e,
          0x4e, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4c,
          0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4b, 0x4b,
          0x4b, 0x4b, 0x4b, 0x4b, 0x4a, 0x4a, 0x4a, 0x4a,
          0x4a, 0x4a, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
          0x49, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x47,
          0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x46, 0x46,
          0x46, 0x46, 0x46, 0x46, 0x45, 0x45, 0x45, 0x45,
          0x45, 0x45, 0x45, 0x44, 0x44, 0x44, 0x44, 0x44,
          0x44, 0x44, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43,
          0x43, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
          0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x40,
          0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3f, 0x3f,
          0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3e, 0x3e, 0x3e,
          0x3e, 0x3e, 0x3e, 0x3e, 0x3d, 0x3d, 0x3d, 0x3d,
          0x3d, 0x3d, 0x3d, 0x3d, 0x3c, 0x3c, 0x3c, 0x3c,
          0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
          0x3b, 0x3b, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
          0x3a, 0x3a, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
          0x39, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
          0x38, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
          0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
          0x36, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
          0x35, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
          0x34, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
          0x33, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
          0x32, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
          0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
          0x30, 0x30, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
          0x2f, 0x2f, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
          0x2e, 0x2e, 0x2e, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
          0x2d, 0x2d, 0x2d, 0x2d, 0x2c, 0x2c, 0x2c, 0x2c,
          0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2b, 0x2b, 0x2b,
          0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2a, 0x2a,
          0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x29,
          0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
          0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
          0x28, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
          0x27, 0x27, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
          0x26, 0x26, 0x26, 0x26, 0x25, 0x25, 0x25, 0x25,
          0x25, 0x25, 0x25, 0x25, 0x25, 0x24, 0x24, 0x24,
          0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x23,
          0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
          0x23, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
          0x22, 0x22, 0x22, 0x21, 0x21, 0x21, 0x21, 0x21,
          0x21, 0x21, 0x21, 0x21, 0x21, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1f,
          0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
          0x1f, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
          0x1e, 0x1e, 0x1e, 0x1e, 0x1d, 0x1d, 0x1d, 0x1d,
          0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1c, 0x1c,
          0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
          0x1c, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
          0x1b, 0x1b, 0x1b, 0x1b, 0x1a, 0x1a, 0x1a, 0x1a,
          0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x19,
          0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
          0x19, 0x19, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
          0x18, 0x18, 0x18, 0x18, 0x18, 0x17, 0x17, 0x17,
          0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
          0x17, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
          0x16, 0x16, 0x16, 0x16, 0x15, 0x15, 0x15, 0x15,
          0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
          0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
          0x14, 0x14, 0x14, 0x14, 0x13, 0x13, 0x13, 0x13,
          0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11,
          0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
          0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
          0x10, 0x10, 0x10, 0x10, 0x10, 0x0f, 0x0f, 0x0f,
          0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
          0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
          0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0d,
          0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
          0x0d, 0x0d, 0x0d, 0x0d, 0x0c, 0x0c, 0x0c, 0x0c,
          0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
          0x0c, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
          0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x0a,
          0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
          0x0a, 0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09,
          0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
          0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06,
          0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
          0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05,
          0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
          0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04,
          0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
          0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
          0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
          0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
          0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
          0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]

# Generate initial guess, x0, for Newton's Method
#
# Input:
#   - x: The 7 MSBs of the significand field for an IEEE 754
#        binary 16/32/64/128 value
#
# Returns:
#   - 8 significant bits of the initial value for x0
#
# While the function returns 8 significant bits it does so
# in a 9-bit field to be able to cover the entire range of
# possible values.
def X0(x):
  tmp = table[x]
  if x:
    return tmp | (1 << 7)
  else:
    return tmp | (1 << 8)

# Return arbitrary bit from an integer
#
# Inputs:
#   - x: integer from which to extract bit
#   - n: number of the bit to be returned counting from the least
#        significant bit. The least significant bit is numbered 0.
#
# Returns:
#   - The nth bit of the integer. Since the function returns a single bit
#     the only possible return values are 0 and 1.
def bit(x, n):
  return (x >> n) & 1;

# Insert binary point into a string representing a binary value
#
# Inputs:
#   - s: string containing binary value. The string has the prefix
#        "0b" followed by one or more digits of either 0 or 1.
#   - n: count of digits to the right of the binary point.
#
# If there aren't enough digits to have at least one binary digit
# to the left of position `n' then the function will left pad the
# string with zeroes.
def add_point(s, n):
  i = n+3 - len(s)
  if i > 0:
    t = s[:2] + (i * "0") + s[2:]
  else:
    t = s
  return t[0:-n] + "_" + t[-n:]

# Parse input arguments:
#
# Options:
#   -h, --help: emit a help string documenting command usage
#   --roundingAttribute: Specify how the final result is to be rounded
#                        Supported rounding modes:
#                        o roundTiesToEven, (default rounding mode)
#                        o roundTowardPositive,
#                        o roundTowardNegative, and
#                        o roundTowardZero.
#
# Input:
#   value: Integer which is to be interpreted as a binary64 value.
#          The value may be entered as binary, octal, decimal, or hexadecimal
#          integer. `value' is optional. If omitted the script will use the
#          hexadecimal value 0x400921fb54442d18 which is the binary64
#          approximation for π.
parser = argparse.ArgumentParser()
parser.add_argument("value", help="Compute reciprocal of this binary64 value; default = π", type=str, nargs="?", default="0x400921fb54442d18")
parser.add_argument("--roundingAttribute", help="Rounding mode for result", choices=["roundTiesToEven", "roundTowardPositive", "roundTowardNegative", "roundTowardZero"], default="roundTiesToEven", required=False)
args = parser.parse_args()

# Set the rounding mode flags:
roundTiesToEven = args.roundingAttribute == "roundTiesToEven"
roundTowardPositive = args.roundingAttribute == "roundTowardPositive"
roundTowardNegative = args.roundingAttribute == "roundTowardNegative"
roundTowardZero = args.roundingAttribute == "roundTowardZero"

#print("roundTiesToEven = " + str(roundTiesToEven))
#print("roundTowardPositive = " + str(roundTowardPositive))
#print("roundTowardNegative = " + str(roundTowardNegative))
#print("roundTowardZero = " + str(roundTowardZero))

# Read the string representing `value' and convert to an integer:
value = eval(args.value)
#print("value = " + str(value) + " (" + hex(value) + ")")

hNEXP = 5
hNSIG = 10
hBIAS = (1 << (hNEXP-1)) - 1
hEMAX = hBIAS
hEMIN = 1 - hBIAS
hSIGNMASK = 1 << (hNEXP+hNSIG)
hEXPMASK = (1 << hNEXP) - 1
hSIGMASK = (1 << hNSIG) - 1

NEXP = 11
NSIG = 52
BIAS = (1 << (NEXP-1)) - 1
EMAX = BIAS
EMIN = 1 - BIAS
SIGNMASK = 1 << (NEXP+NSIG)
EXPMASK = (1 << NEXP) - 1
SIGMASK = (1 << NSIG) - 1

X0WIDTH = 8

# Extract the sign, exponent, and significand fields.
# Add the implied leading one bit to the significand.
sign = (value & SIGNMASK) != 0
# Extract biased exponent value
exp = (value >> NSIG) & EXPMASK
# So far, we can only process Normal numbers:
if (exp == 0) or (exp == SIGNMASK):
  sys.exit("This script can't process NaNs, Infinities, Zeroes, or Subnormal numbers.")

# Subtract BIAS value to get actual signed exponent
exp -= BIAS
# Compute starting exponent value for the reciprocal
rexp = -exp
# Extract significand and prepend the implicit leading 1 digit
sig = (value & SIGMASK) | (1 << NSIG)
# Show the user the values of the sign, unbiased exponent, and significand
print("sign, exponent, significand: " + str(sign) + " " + str(exp) + " " + add_point(bin(sig),NSIG))

# Get initial guess for the significand of the reciprocal:
# x0 padded to have NSIG+1 bits to the right of the binary point
x0 = X0((value>>(NSIG-hNSIG) & hSIGMASK)) << (NSIG+1-X0WIDTH)
print("x0 = " + add_point(bin(x0),NSIG+1))

# Calculate smallest power of 2 ≥ NSIG+1. The value clog2 is
# used to control how many iterations of Newton's Method are
# required to get maximum accuracy for this floating point data
# format.
clog2 = 0
while (NSIG+1) > (1 << clog2): # (NSIG+1) > (2**clog2)
  clog2 += 1

for i in range(clog2-3):
  # x1a has 2*NSIG+1 bits to the right of the binary point
  x1a = sig * x0
  print("x" + str(i+1) + "a = " + add_point(bin(x1a),2*NSIG+1))

  # x1b has 2*NSIG+1 bits to the right of the binary point
  x1b = (2 << (2*NSIG+1)) - x1a
  print("x" + str(i+1) + "b = " + add_point(bin(x1b),2*NSIG+1))

  # x1 has 3*NSIG+2 bits to the right of the binary point
  x1 = x1b * x0
  print("x" + str(i+1) + " = " + add_point(bin(x1),3*NSIG+2))

  # Truncate x0 to only have NSIG+1 bits to the right of the binary point
  x0 = x1 >> (2*NSIG+1)
  print("x" + str(i+1) + " = " + add_point(bin(x0),NSIG+1))

# Normalize, if needed
if not bit(x1,3*NSIG+2):
  rexp -= 1
  x1 <<= 1
print("After normalizing: x" + str(clog2-3) + " = " + add_point(add_point(add_point(add_point(bin(x1),3*NSIG+2),3*NSIG+2+1-NSIG),3*NSIG+2-NSIG),3*NSIG+2-1-NSIG) + ", rexp = " + str(rexp))

# Round x1 to (NSIG+1) bits:
# Step 1: Find the values needed to actually perform the rounding
print("roundingAttribute is " + args.roundingAttribute)

lastKeptBitIsOdd = bit(x1,3*NSIG+2-NSIG) == 1
print("lastKeptBitIsOdd is " + str(lastKeptBitIsOdd))

decidingBitIsOne = bit(x1,3*NSIG+2-1-NSIG) == 1
print("decidingBitIsOne is " + str(decidingBitIsOne))

remainingBitsAreNonzero = (x1 & ((1 << (3*NSIG+2-1-NSIG)) - 1)) != 0
print("remainingBitsAreNonzero is " + str(remainingBitsAreNonzero))

# Step 2: Perform the rounding
roundBit = 1 if (roundTiesToEven and decidingBitIsOne and (lastKeptBitIsOdd or remainingBitsAreNonzero)) or (roundTowardPositive and (not sign) and (decidingBitIsOne or remainingBitsAreNonzero)) or (roundTowardNegative and sign and (decidingBitIsOne or remainingBitsAreNonzero)) else 0
print("roundBit is " + str(roundBit))
x1 >>= 3*NSIG+2 - NSIG
print("After truncating: x" + str(clog2-3) + " = " + add_point(bin(x1),NSIG))
x1 += roundBit
print("After rounding: x" + str(clog2-3) + " = " + add_point(bin(x1),NSIG))

# Step 3: Again, if needed, renormalize the rounded result
if bit(x1,(NSIG+1)):
  rexp += 1
  x1 >>= 1
print("After renormalizing: x" + str(clog2-3) + " = " + add_point(bin(x1),NSIG) + ", rexp = " + str(rexp))

print("Verify product is close to 1:")
p = sig * x1
# Add a 2nd "_" to mark the end of (NSIG+1) bits of precision
print("- product of significands: " + add_point(add_point(bin(p),2*NSIG),NSIG+bit(p,2*NSIG+1)))
print("- sum of exponents: " + str(exp+rexp))

if (rexp < EMIN) or (EMAX < rexp):
  sys.exit("Reciprocal is not a Normal IEEE 754 number.")

# Output reciprocal as a 64-bit hexadecimal integer:
sign = SIGNMASK if sign else 0
print("Reciprocal is " + hex(sign | ((rexp + BIAS) << NSIG) | (x1 & SIGMASK)))
